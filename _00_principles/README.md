## 单一职责原则（SRP）

就一个类而言，应该仅有一个引起它变化的原因。

对于我们编程来说，要在类的职责分离上多思考，做到单一职责，这样你的代码才是真正的易维护、易扩展、易复用、灵活多样。

## 开放-封闭原则（OCP）

Open-Closeed Principle

开放-封闭原则，是说软件实体（类、模块、函数等）应该可以扩展，但是不可修改。

这个原则其实是有两个特征，一个是说'对于扩展是开放的（Open for extension）'，另一个是说'对于修改是封闭的（Closed for modification）'

![image-20231023211518374](https://cdn.jsdelivr.net/gh/vincent-nicky/image_store/blog/image-20231023211518374.png)

我们在做任何系统的时候，都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推倒重来。怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？，开放-封闭给了我们答案。

无论模块是多么的'封闭'，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。

在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。

面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。这就是'开放-封闭原则'的精神所在。

我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。

开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。

## 依赖倒转原则

（1）高层模块不应该依赖低层模块。两个都应该依赖抽象。

（2）抽象不应该依赖细节。细节应该依赖抽象。（要针对接口编程，不要对实现编程）

例如PC里如果CPU、内存、硬盘都需要依赖具体的主板，主板一坏，所有的部件就都没用了，这显然不合理。反过来，如果内存坏了，也不应该造成其他部件不能用才对。

如果不管高层模块还是低层模块，它们都依赖于抽象， 具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个更改都不用担心其他受到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。这才是最好的办法。

![image-20231023215335527](https://cdn.jsdelivr.net/gh/vincent-nicky/image_store/blog/image-20231023215335527.png)

#### 里氏代换原则（LSP）

子类型必须能够替换掉它们的父类型。

一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。

![image-20231023214007655](https://cdn.jsdelivr.net/gh/vincent-nicky/image_store/blog/image-20231023214007655.png)

上面的图，如果要让企鹅继承鸟，那么让鸟有下蛋的方法可以，但有飞的方法就不对了。尽管在生物学分类上，企鹅是一种鸟，但在编程世界里，企鹅不能以父类——鸟的身份出现，因为前提说所有鸟都能飞，而企鹅飞不了，所以，企鹅不能继承鸟类。

只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。

比方说，猫是继承动物类的，以动物的身份拥有吃喝、移动（跑、飞、游等）等行为，可当某一天，我们需要狗、 牛、羊也拥有类似的行为，由于它们都是继承于动物，所以除了更改实例化的地方，程序其他处不需要改变。

![image-20231023215101717](https://cdn.jsdelivr.net/gh/vincent-nicky/image_store/blog/image-20231023215101717.png)

正是由于子类型的可替换性才使得使用父类类型的模块在无须修改的情况下就可以扩展。不然还谈什么扩展开放，修改关闭呢？ 再回过头来看依赖倒转原则，高层模块不应该依赖低层模块，两个都应该依赖抽象，对这句话你就会有更深入的理解了。

![image-20231023215324438](https://cdn.jsdelivr.net/gh/vincent-nicky/image_store/blog/image-20231023215324438.png)

依赖倒转其实就是谁也不要依靠谁，除了约定的接口， 大家都可以灵活自如。

依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。